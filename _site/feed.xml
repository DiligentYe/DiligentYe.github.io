<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-05T20:47:43+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Test</title><subtitle>Good Good Study, Day Day Up!</subtitle><entry><title type="html">开发Chrome扩展——Nodejs Debugger</title><link href="http://localhost:4000/node/2018/10/05/%E5%BC%80%E5%8F%91Chrome%E6%89%A9%E5%B1%95_Nodejs-Debugger.html" rel="alternate" type="text/html" title="开发Chrome扩展——Nodejs Debugger" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/node/2018/10/05/%E5%BC%80%E5%8F%91Chrome%E6%89%A9%E5%B1%95_Nodejs%20Debugger</id><content type="html" xml:base="http://localhost:4000/node/2018/10/05/%E5%BC%80%E5%8F%91Chrome%E6%89%A9%E5%B1%95_Nodejs-Debugger.html">&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-be1c852b0ca34f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Node.js Debugger&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Node.js Debugger扩展展示及下载地址&lt;/li&gt;
  &lt;li&gt;Node.js Debugger使用介绍&lt;/li&gt;
  &lt;li&gt;Node.js Debugger开发思想&lt;/li&gt;
  &lt;li&gt;待改进&lt;/li&gt;
  &lt;li&gt;相关资料&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-nodejs-debugger扩展展示及下载地址&quot;&gt;1. Node.js Debugger扩展展示及下载地址&lt;/h3&gt;
&lt;h4 id=&quot;nodejs-debugger扩展展示&quot;&gt;Node.js Debugger扩展展示&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始页面
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-6a69581ae22d879d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;初始展示页面&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作失败页面
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-d4b5f305466e8e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;操作失败页面&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nodejs-debugger扩展下载地址&quot;&gt;Node.js Debugger扩展下载地址&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;百度网盘地址：&lt;/strong&gt;&lt;a href=&quot;https://pan.baidu.com/s/1c1KLk5a&quot;&gt;https://pan.baidu.com/s/1c1KLk5a&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-nodejs-debugger使用介绍&quot;&gt;2. Node.js Debugger使用介绍&lt;/h3&gt;
&lt;h4 id=&quot;安装chrome扩展&quot;&gt;安装Chrome扩展&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;打开Chrome扩展程序面板。&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-508c712155506f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;扩展工具程序面板入口&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.直接将的.crx文件拖拽到扩展程序面板中，添加扩展程序。&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-caee8bf6ad115fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2017-11-30 13.23.31.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;添加扩展程序成功，可以在工具栏看到我们扩展程序的图标（绿色小图标）。&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-b7228f890c2f0283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;添加成功提示&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nodejs-debugger扩展程序使用介绍&quot;&gt;Node.js Debugger扩展程序使用介绍&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;输入主机名和端口号，默认情况下主机名为localhost，端口号为9229，如果在启动node inspector时，你使用的不是–inspect，而是–inspect=127.0.0.1:8000，此时Chrome与node inspector的通信端口为8000，因此，你需要重新设置端口。
&lt;strong&gt;情况一：&lt;/strong&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-fe7160ba73ad2033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;使用--inspect参数&quot; /&gt;此时，打开Chrome，点击扩展程序，直接点击调试即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;情况二：&lt;/strong&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-398cd9ec38464978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;使用--inspect=ip:port参数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-d3b636b04125b15c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;设置端口号9000&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，就必须设置端口号，如果不设置点击调试的话，就会弹出弹出层，而不能正确访问调试页面。&lt;/p&gt;

&lt;h4 id=&quot;使用过程中注意事项&quot;&gt;使用过程中注意事项&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确保node版本是7.x.x以上
node inspector功能是在7.x.x版本以上才能使用。因此，如果当你点击调试按钮，弹出先标签页，但是页面一直在转圈，此时，你就要查看一下，是否是你的node版本太低了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确保启动了node inspector，并且&lt;strong&gt;建议使用–inspect-brk来启动&lt;/strong&gt;
如果你使用–inspect启动node inspector，并且你调试的只是一个过程式的js，此时你的代码在调试之前就已经执行完，无法再进行调试，而是用–inspect-brk来启动，将在所有程序的开头开始调试，此时，你便可以在调试面板上添加断点进行调试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口号设置问题
确定输入框中设置的端口号是否正确，并且端口号是否已经被占用。如果你设置的端口号已经已经被使用了，此时插件内部可能报错，但是并不会直接显示到插件展示页面上，因此，如果发现点击调试按钮不弹出弹出层，也不弹出新的标签页，请检查你的端口号是否被占用了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一次调试完成后，不能直接刷新页面，开始下一轮调试
此时需要重新启动新的node inspector，在按照上面的步骤打开页面，否则可能会出现，无法进行调试，或者无法打开调试页面的情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-nodejs-debugger开发思想&quot;&gt;3. Node.js Debugger开发思想&lt;/h3&gt;
&lt;p&gt;Inspector clients must know and specify host address, port, and UUID to connect to the WebSocket interface. The full URL is ws://127.0.0.1:9229/0f2c936f-b1cd-4ac9-aab3-f63b0f33d55e, of course dependent on actual host and port and with the correct UUID for the instance.
Node.js v7+版本提供了一个inspector的功能，在使用node运行js程序时，可以添加–inspector打开这个功能。
&lt;strong&gt;该功能为Chrome DevTools提供了一个通信接口，这是的Node进程可以和Chrome DevTools使用websocket直接进行通信&lt;/strong&gt;。
同时，也提供了用户接口，用户可以通过访问
&lt;strong&gt;http://IP:port/json/list&lt;/strong&gt;访问到这个接口的相关信息，其中webSocketDebuggerUrl就是Chrome DevTools和Node进程的websocket通信地址，而&lt;strong&gt;devtoolsFrontendUrl，就是我们可以访问的调试面板地址&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ {
  &quot;description&quot;: &quot;node.js instance&quot;,
  &quot;devtoolsFrontendUrl&quot;: &quot;chrome-devtools://devtools/bundled/inspector.html?experiments=true&amp;amp;v8only=true&amp;amp;ws=127.0.0.1:9000/ce3d915c-367e-4751-980c-a50cede6379d&quot;,
  &quot;faviconUrl&quot;: &quot;https://nodejs.org/static/favicon.ico&quot;,
  &quot;id&quot;: &quot;ce3d915c-367e-4751-980c-a50cede6379d&quot;,
  &quot;title&quot;: &quot;test.js&quot;,
  &quot;type&quot;: &quot;node&quot;,
  &quot;url&quot;: &quot;file:///Users/yyp/Desktop/test.js&quot;,
  &quot;webSocketDebuggerUrl&quot;: &quot;ws://127.0.0.1:9000/ce3d915c-367e-4751-980c-a50cede6379d&quot;
} ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因此我们&lt;strong&gt;通过http://IP:port/json/list返回数据中的devtoolsFrontendUrl字段，获取调试页面地址，然后在chrome插件中创建一个新的标签页，并且将该字段作为新标签页的url即可&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-待改进&quot;&gt;4. 待改进&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;启动扩展程序时，第一个输入框被选中，出现蓝色背景。&lt;/li&gt;
  &lt;li&gt;未提供用户设置选项。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-相关资料&quot;&gt;5. 相关资料&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;node inspector 相关
&lt;a href=&quot;https://nodejs.org/en/docs/guides/debugging-getting-started/#debugging-guide&quot;&gt;&lt;strong&gt;Debugging Guide&lt;/strong&gt;: https://nodejs.org/en/docs/guides/debugging-getting-started/#debugging-guide&lt;/a&gt;
&lt;a href=&quot;https://nodejs.org/en/docs/inspector/&quot;&gt;&lt;strong&gt;Debugging Node.js Apps&lt;/strong&gt;: https://nodejs.org/en/docs/inspector/&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/p/3ed910d3866c&quot;&gt;&lt;strong&gt;如何在Chrome DevTools 中对Node程序进行调试&lt;/strong&gt;: http://www.jianshu.com/p/3ed910d3866c&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Chrome 插件开发相关
&lt;a href=&quot;http://www.ituring.com.cn/book/1421&quot;&gt;&lt;strong&gt;Chrome扩展及应用开发（首发版）&lt;/strong&gt;:http://www.ituring.com.cn/book/1421&lt;/a&gt;
&lt;a href=&quot;https://chajian.baidu.com/developer/extensions/getstarted.html&quot;&gt;&lt;strong&gt;百度浏览器开发文档&lt;/strong&gt;：https://chajian.baidu.com/developer/extensions/getstarted.html&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源码
&lt;a href=&quot;https://github.com/DiligentYe/todo-list-chrome-extension/tree/nodejs-debugger&quot;&gt;&lt;strong&gt;github地址&lt;/strong&gt;：https://github.com/DiligentYe/todo-list-chrome-extension/tree/nodejs-debugger&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">拼图小游戏模块开发总结</title><link href="http://localhost:4000/javascript/2018/10/05/%E6%8B%BC%E5%9B%BE%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="拼图小游戏模块开发总结" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/javascript/2018/10/05/%E6%8B%BC%E5%9B%BE%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/javascript/2018/10/05/%E6%8B%BC%E5%9B%BE%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html">&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-e62ff5feabab9a37.jpg&quot; alt=&quot;封面&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;成果展示&lt;/li&gt;
  &lt;li&gt;开发过程中考虑的问题&lt;/li&gt;
  &lt;li&gt;项目源码及使用方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;成果展示&quot;&gt;成果展示&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-631175a909ee5a7c.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;最终实现成果&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;开发过程中考虑的问题&quot;&gt;开发过程中考虑的问题&lt;/h4&gt;
&lt;h5 id=&quot;布局展示方面&quot;&gt;布局展示方面&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如何创建屏幕自适应的正方形盒子
&lt;strong&gt;自适应宽度：&lt;/strong&gt;
考虑到拼图游戏会被添加到不同宽度的盒子中，如直接引入到不同分辨率的手机中，或不同指定宽度的盒子中，在这里，我们使用&lt;strong&gt;width: 100%&lt;/strong&gt;，来设置正方形容器的宽度，让容器的宽度完全等于外部元素的宽度（因为块级元素独占一行，继承父元素的宽度，因此可以不用设置）。
&lt;strong&gt;正方形盒子：&lt;/strong&gt;
使用&lt;strong&gt;padding-top: 100%&lt;/strong&gt;让容器成为一个正方形，因为padding设置为百分比时，也是根据父元素的宽度进行计算的，并且在计算盒子的大小时，是包括在内的，（更明显一点的行为为，background会影响padding但是不会影响border,margin）。
但是此时并没有完成，此时如果在标签中添加元素的话，元素会布局到padding-top的下面，撑高我们的容器，并不能达到我们要的效果，因此需要在添加一个内层的盒子并且将这个盒子相对于外层容器决定定位到左上角，然后由容器中的内容来撑高。（在这里我通过脚本计算，根据当前外层盒子的宽度，计算每个小图片的宽度，然后完美撑高盒子，如果使用CSS来设置，则需要配合box-size: padding-box;）。
&lt;strong&gt;具体实现：&lt;/strong&gt;
```
CSS:
 #outer {
             /&lt;em&gt;设置相对定位&lt;/em&gt;/
         position: relative;
     /&lt;em&gt;设置正方形&lt;/em&gt;/
     /&lt;em&gt;width属性会继承，块级元素可以不用设置&lt;/em&gt;/
     /&lt;em&gt;width: 100%;&lt;/em&gt;/
     padding-top: 100%;
     background: rgb(250, 250, 0);
 }&lt;/p&gt;

    &lt;p&gt;#inner {
     /&lt;em&gt;定位到左上角&lt;/em&gt;/
     position: absolute;
     top: 0;
     left: 0;
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTML: 
	&amp;lt;div id=&quot;outer&quot;&amp;gt;
		&amp;lt;div id=&quot;inner&quot;&amp;gt;Happy Everyday&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![正方形容器](http://upload-images.jianshu.io/upload_images/5796375-9dc219fb2a128a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**知识点：**：
使用百分值设置盒模型（margin，border，padding，width，height）时，margin，padding，width都是相对于父元素的width，而height是相对于父元素的height（特殊：border的宽度为特定值，或者0）。

2. 如何获取这个盒子的宽度
**计算样式：**
计算样式：指的是经过浏览器进行整体处理后的综合结果。
在这里，可以通过js来获取这个值：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var style = document.defaultView.getComputedStyle(ele, null);
// 获取宽度
var width = parseInt(style.width);
```
&lt;strong&gt;注意点：&lt;/strong&gt; 
使用这个函数返回的是一个对&lt;strong&gt;当前这个元素所有计算样式的引用&lt;/strong&gt;，因此如果你在保存这个引用之后重新修改了样式，其中的样式值也会随之改变。
还有一点是，这个计算样式对象的所有属性值都是字符串，如果我们需要获取数值类型的数据，需要进一步进行处理。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如何确定内部小方块的大小
&lt;strong&gt;外层容器处理：&lt;/strong&gt;
让外层容器刚好可以被整除
w_container(容器宽度) -= w_container % base(每行的方块个数) ； 
&lt;strong&gt;方块宽度计算公式（考虑到border）：&lt;/strong&gt;
w_ceil(小方块宽度) = Math.floor(w_container(容器宽度) / base) - 2 * border
&lt;strong&gt;注意点：&lt;/strong&gt;
在小方块的宽度+border总和实际上是小于外部容器的宽度，base值越大，差值越大，就会导致不居中的问题。解决方式：将中间层容器设置dispaly: inner-block; 然后最外层设置text-align: center;让容器居中。
方块设置为：dispaly: inner-block;排列时会出现缝隙的问题，是由于inner-block具有行内元素的特性，换行会出现空白折叠现象，每个方块之间出现一个空白。解决方式：font-size: 0;即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片的展示方式
直接使用背景图片的方式，结合使用background-image, background-position, background-size来实现。
&lt;strong&gt;注意点：&lt;/strong&gt;
图片的定位：background-position，是根据background-size的大小进行设置的，如果没有设置后者，则是根据实际大小来设置，但是如果设置了，则根据设置的大小进行定位。且定位的值都为负值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;图片处理逻辑&quot;&gt;图片处理逻辑&lt;/h5&gt;
&lt;p&gt;将图片切割成n&lt;em&gt;n份，然后从左到右，从上到下，一起进行编号（0 ~n&lt;/em&gt;n-1），采用一个数组来存放当前图片的实际顺序（即方块中对应的图片索引）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图片定位
给定一个图片的位置，则：
row：position / 3
col:   postion % 3 
最终位置为（左上角为(0, 0)）：
x = col * w_ceil(方块宽度)
y = row * w_ceil(方块宽度)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片打乱
每次上述数组中的两个点，然后互换这两个点中的内容，重复多次这样的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拼图检测
如果数组中对应元素和索引值相等，则此时图片即在正确的位置上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;其他方面&quot;&gt;其他方面&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;页面结构和基础样式，只在初始化是进行一次处理，重新开始游戏时，只图片不会对整个拼图模块进行重新布局。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOM引用本地化：在脚本运行时，便对需要使用的页面元素进行本地化，减少DOM操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现了封装，将所有将页面结构，样式，处理逻辑都封装在内部，只对提供了一些api以及可配置项，只需要引入一个js文件，调用相应api，即可实现一个拼图游戏&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;项目源码及使用方法&quot;&gt;项目源码及使用方法&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DiligentYe/puzzle&quot;&gt;github线上地址&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">滚动穿透问题</title><link href="http://localhost:4000/javascript/2018/10/05/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.html" rel="alternate" type="text/html" title="滚动穿透问题" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/javascript/2018/10/05/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/javascript/2018/10/05/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.html">&lt;h4 id=&quot;问题描述&quot;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;当浮层滚动触底时, 再次滑动浮层时, 浮层下面的页面会进行滚动, 即滚动穿透&lt;/p&gt;

&lt;h4 id=&quot;解决办法&quot;&gt;解决办法&lt;/h4&gt;
&lt;p&gt;通过__position: fixed__将body固定在当前位置, 关闭浮层时, 再将清除该样式, 将页面滚动值设置为之前的值.&lt;/p&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;stopBodyScroll&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isFixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isFixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'fixed'&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'px'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 回到原先的top&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关闭浮层, 恢复滚动时, 不能不能使用document.documentElement.scrollTop的值, 由于设置了position, 其值为0, 因此需要通过top的值获取&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PC端可以直接通过设置body的overflow: hidden属性, 来固定底层页面, 但是该方法再移动端无效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">问题描述 当浮层滚动触底时, 再次滑动浮层时, 浮层下面的页面会进行滚动, 即滚动穿透</summary></entry><entry><title type="html">Sublime-Text3自动保存的功能(失去焦点自动保存)</title><link href="http://localhost:4000/tool/2018/10/05/Sublime_Text3%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E7%9A%84%E5%8A%9F%E8%83%BD(%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98).html" rel="alternate" type="text/html" title="Sublime-Text3自动保存的功能(失去焦点自动保存)" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/tool/2018/10/05/Sublime_Text3%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E7%9A%84%E5%8A%9F%E8%83%BD(%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98)</id><content type="html" xml:base="http://localhost:4000/tool/2018/10/05/Sublime_Text3%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E7%9A%84%E5%8A%9F%E8%83%BD(%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98).html">&lt;h3 id=&quot;第一步&quot;&gt;第一步&lt;/h3&gt;
&lt;p&gt;preferences 下面的settings；(和老版本的不一样了吧,之前有什么default 和 users,这里只有settings)
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-db92f4e1c51ebd87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mac 版本settings文件位置&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;第二步&quot;&gt;第二步&lt;/h3&gt;
&lt;p&gt;现在分两边了,左边文件是默认配置，右边文件是用户自定义配置，左边是只读的不能编辑,在左边ctrl + f ,然后在下面输入框里输入save_on_focus_lost，在右边文件中设置为true。保存文件即可。
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-7f6bfd9a787d2fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-03-28 14.29.16.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">第一步 preferences 下面的settings；(和老版本的不一样了吧,之前有什么default 和 users,这里只有settings)</summary></entry><entry><title type="html">Centos7中英文输入法切换</title><link href="http://localhost:4000/linux/2018/10/05/Centos7%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2.html" rel="alternate" type="text/html" title="Centos7中英文输入法切换" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/linux/2018/10/05/Centos7%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2</id><content type="html" xml:base="http://localhost:4000/linux/2018/10/05/Centos7%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2.html">&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-101394e572211503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Centos  7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如何在liunx系统中输入中文，且能在中英文之间自如切换，看了下面的介绍，你就清楚啦！&lt;/p&gt;

&lt;h3 id=&quot;linux系统中是否已经安装中文字符包&quot;&gt;linux系统中是否已经安装中文字符包&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;三种方法进行检测：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果你是选择中文安装系统，成功后你的系统肯定就已经安装了中文字符包啦！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.也可以在终端输入&lt;strong&gt;echo $LANG&lt;/strong&gt;，如果输出为zh_CN开头，代表本地语言是中文，肯定安装了中文字符包。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-872bbe49a25e91ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;查看本地语言&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查看&lt;strong&gt;/etc/locale.conf&lt;/strong&gt;文件内容，在终端输入&lt;strong&gt;cat /etc/locale.conf&lt;/strong&gt;。&lt;strong&gt;注意：&lt;/strong&gt;centos有些版本中，不是/etc/locale.conf而是/etc/sysconfig/i18n。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-8832ebaab5228b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;查看系统语言配置文件&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果确认你没有安装中文文字包，执行以下命令安装即可。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum -y groupinstall chinese-support
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;centos中设置中英文切换&quot;&gt;Centos中设置中英文切换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-362302c13a0df22c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;打开设置面板&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-75ce77c4aaae09e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击区域和语言&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-35e5d718e300429c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击+号添加输入源&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-57a752bc3d0ead1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击+号后选择汉语（中国）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-8e69340a6febc9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;必须 选择汉语（Intelligent Pinyin）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-5836c6b64e6d385a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击键盘选项&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-754aebba43ec4e7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;设置切换输入源快捷键&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-2722fadb20a7b7bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;可切换输入源，可用快捷键直接进行切换&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加输入源之前，检查你是否已经具有&lt;strong&gt;汉语（Intelligent Pinyin）&lt;/strong&gt;输入源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;汉语的输入源必须是&lt;strong&gt;汉语（Intelligent Pinyin）&lt;/strong&gt;，否则无法打出中文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最好自定义中引文切换快捷键，用自己最熟悉的按键&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以上实践都是在Centos 7 上进行实践，未验证其他版本。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/linghao00/article/details/6804411&quot;&gt;http://blog.csdn.net/linghao00/article/details/6804411&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Charles抓包工具安装与配置</title><link href="http://localhost:4000/tool/2018/10/05/Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html" rel="alternate" type="text/html" title="Charles抓包工具安装与配置" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/tool/2018/10/05/Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/tool/2018/10/05/Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html">&lt;p&gt;在实际开发中，我们需要时常抓取线上的请求及数据，甚至是请求的html文档，js，css等静态文件来进行调试。在这里，我使用charles来进行以上操作。但是呢，charles需要进行一系列配置才能达到我们的要求。下面将介绍一个mac下详细且完整的安装和配置过程。&lt;/p&gt;

&lt;h4 id=&quot;1-下载和安装charles&quot;&gt;1. 下载和安装Charles&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles官网&lt;/a&gt;下载，然后按照正常流程安装即可。&lt;/p&gt;

&lt;h4 id=&quot;2-破解charles&quot;&gt;2. 破解Charles&lt;/h4&gt;
&lt;p&gt;详细步骤：&lt;a href=&quot;http://charles.iiilab.com/&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-配置手机&quot;&gt;3. 配置手机&lt;/h4&gt;
&lt;p&gt;手机连接同局域网，设置网络的代理服务器为该电脑的ip地址，端口为8888，此时你已经可以抓取http请求了&lt;/p&gt;

&lt;h4 id=&quot;4-配置抓包https请求&quot;&gt;4. 配置抓包HTTPS请求&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;安装Charles HTTPS证书
路径：help–&amp;gt;SSLProxying–&amp;gt; Install Charles Root Ceriticate&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-65a8d281dfb2bda0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击Install Charles Root Ceriticate后，会直接跳到钥匙串中。但是呢，这个证书并不能信任，此时我们可以点击Charles Proxy CA，就会弹出第二张图，在信任中选择“始终信任”即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-a1451ec74e76c853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-8d2f0fc8c0abe0f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然也并不是所有人都能很顺利的执行第一步，即在申请发布证书时双击安装出现不能修改System Roots钥匙串问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-6fd6c16e6cc5967d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，你只需点击左下角的小图标，点击进入“登录”标签，然后通过help–&amp;gt;SSLProxying–&amp;gt; Save Charles Root Ceriticate… 然后将保存的文件直接拖到面板中即可。然后设置信任。。。&lt;/p&gt;

&lt;p&gt;当电脑上已经安装好证书之后，我们将需要调试的手机设置该电脑为代理服务器，端口为8888&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;手机端下载证书
通过help–&amp;gt;SSLProxying–&amp;gt; Install Charles Root Ceriticate on a Mobile Device or Remote Browser，可以获得下载提示，将Charles设置为http代理，然后访问chl.pro/ssl（网址可能会不同，因此一定要通过点击获得的提示信息）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-19eb57d37db7c585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设置代理https端口
通过Proxy–&amp;gt;SSL Proxying Settings&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-57c0ad1fc2845655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-9533b69e86548be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样一来，你就可以通过Charles作为代理服务器，获取想要的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 最重要一点：手机信任charles证书&lt;/strong&gt;
通过第5步手机端下载证书，在苹果手机上默认是不信任的（安卓手机未确认），因此需要在手机端中信任安装的证书。&lt;/p&gt;

&lt;p&gt;设置–&amp;gt;通用–&amp;gt; 关于本机–&amp;gt;证书信任设置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-76bd48139b0465d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/310&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5796375-a25aaa9a1e3066c6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/310&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后说一点，重要的一点，如果你使用charles抓https请求，一定要链接以太网口，不能连接无线网。&lt;/p&gt;</content><author><name></name></author><summary type="html">在实际开发中，我们需要时常抓取线上的请求及数据，甚至是请求的html文档，js，css等静态文件来进行调试。在这里，我使用charles来进行以上操作。但是呢，charles需要进行一系列配置才能达到我们的要求。下面将介绍一个mac下详细且完整的安装和配置过程。</summary></entry><entry><title type="html">JavaScript中函数中的this到底是什么</title><link href="http://localhost:4000/javascript/2018/10/05/JavaScript%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88.html" rel="alternate" type="text/html" title="JavaScript中函数中的this到底是什么" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/javascript/2018/10/05/JavaScript%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88</id><content type="html" xml:base="http://localhost:4000/javascript/2018/10/05/JavaScript%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88.html">&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;函数中this是什么&lt;/li&gt;
  &lt;li&gt;如何改变this的指向（call, apply, bind）&lt;/li&gt;
  &lt;li&gt;上述方法的不同点&lt;/li&gt;
  &lt;li&gt;bind方法的实现原理&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;正文&quot;&gt;正文&lt;/h4&gt;
&lt;h5 id=&quot;1-函数中this是什么&quot;&gt;1. 函数中this是什么&lt;/h5&gt;
&lt;p&gt;this，是指向当前函数的运行环境，也就是执行上下文。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当直接在浏览器全局环境中调用函数，那么，this指向的就是Window对象；&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function simple() {
	console.log(this);
}
// 直接在全局找那个调用
simple();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-bf9de464b00d2c2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;全局中调用函数中的this&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;strong&gt;直接调用&lt;/strong&gt;特定对象中的方法时，此时这个方法就运行在这个特定对象的中；
````
var runEnv = {
 name: ‘yyp’,
 age: 18,&lt;/p&gt;

    &lt;p&gt;printThis: function() {
     console.log(this);
 }
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;// 运行runEnv对象中printThis方法
runEnv.printThis();&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![特定对象中方法的this](http://upload-images.jianshu.io/upload_images/5796375-01f5edff36496bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

3. 特殊情况：如果我们在全局中保留了特定对象中方法的引用后， 直接在全局中执行，这是，由于此时的方法，是在全局环境中执行的，因此this指向全局；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var runEnv = {
	name: ‘yyp’,
	age: 18,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printThis: function() {
	console.log(this);
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// 在全局中保留runEnv对象中printThis方法的引用
var cloneFun = runEnv.printThis;&lt;/p&gt;

&lt;p&gt;// 在全局中运行这个函数
cloneFun();&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![在全局中运行保存的新引用](http://upload-images.jianshu.io/upload_images/5796375-c2765af61cb441a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

4. 使用new进行调用
使用new调用情况则有所不同，首先会先创建一个新对象，然后将函数的this指向指向这个新对象，然后函数中所有语句都是在这个运行作用域上执行，最后返回这个新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}
// 调用Person构造函数
var person = new Person(‘yyp’, 12);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![刚进如函数时this和执行完两条语句后的this](http://upload-images.jianshu.io/upload_images/5796375-4bfc76156c9486ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面四种情况可以得出，this在一个动态的概念，相对于运行过程的。

##### 2. 如何改变this的指向（call, apply, bind）
以上，是this的一些常规指向情况，在实际开发中，可以根据实际的需求，改变函数中的this指向。call, apply, bind都是函数原型上的方法，因此每个函数都可以调用这些方法。

##### 2 使用方法简介
1. call方法
**语法：** fun.call(thisArg[, arg1[, arg2[, ...]]])
thisArg：运行时this的指向
 arg1, arg2, ...： 可选传递给函数的参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var person1 = {
	name: ‘yyp’
}&lt;/p&gt;

&lt;p&gt;var person2 = {
	name: ‘wg’
}&lt;/p&gt;

&lt;p&gt;function sayHi() {
	console.log(‘Hi, ‘ + this.name);
}&lt;/p&gt;

&lt;p&gt;// 绑定this指向person1
sayHi.call(person1);&lt;/p&gt;

&lt;p&gt;// 绑定this指向person2
sayHi.call(person2);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![最终运行结果](http://upload-images.jianshu.io/upload_images/5796375-06f78cf68000d8f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. apply方法
**语法：** fun.apply(thisArg, [argsArray])
thisArg：运行时this的指向
argsArray： 传递给函数的参数列表**数组**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var person1 = {
	name: ‘yyp’
}&lt;/p&gt;

&lt;p&gt;var person2 = {
	name: ‘wg’
}&lt;/p&gt;

&lt;p&gt;function sayHi() {
	console.log(‘Hi, ‘ + this.name);
}&lt;/p&gt;

&lt;p&gt;// 绑定this指向person1
sayHi.apply(person1);&lt;/p&gt;

&lt;p&gt;// 绑定this指向person2
sayHi.apply(person2);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面列出的代码，和上一次的代码只是将call方法变为apply，具体apply和call用户不同，下文会单独进行解释。

3. bind方法
**语法：** fun.bind(thisArg[, arg1[, arg2[, ...]]])；
thisArg：运行时this的指向
 arg1, arg2, ...： 可选传递给函数的参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var person1 = {
	name: ‘yyp’
}&lt;/p&gt;

&lt;p&gt;var person2 = {
	name: ‘wg’
}&lt;/p&gt;

&lt;p&gt;function sayHi() {
	console.log(‘Hi, ‘ + this.name);
}&lt;/p&gt;

&lt;p&gt;// 绑定this指向person1，返回一个函数
var hello_person1 = sayHi.bind(person1);
// 执行函数
hello_person1();&lt;/p&gt;

&lt;p&gt;// 绑定this指向person2，返回一个函数
var hello_person2 = sayHi.bind(person2);
// 执行函数
hello_person2();&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;最终的运行结果和上面两种情况中一样。

##### 3. 上述方法的不同点
1.  call和apply方法的不同之处
call，apply方法主要是在传递参数的方式上不同，上面举例的函数不需要提供参数，因此，两个可以交替使用。
但是当函数调用需要传递参数时，两者的使用方法就不一样了，有上面提供的语法格式可以知道，**call方法将需要传递的参数平铺，一个一个的传递，而apply方法，则需要将所有需要传递的参数放到一个数组中，然后传递给函数**。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var runEnv = {
	name: ‘yyp’
}&lt;/p&gt;

&lt;p&gt;function sayHi(str) {
	console.log(str + ‘ ‘ + this.name);
}&lt;/p&gt;

&lt;p&gt;// 使用call方法绑定this，并传递参数，将参数依次传递
sayHi.call(runEnv, ‘Hi!’);&lt;/p&gt;

&lt;p&gt;// 使用bind方法绑定this，并传递参数，所有传入的参数，需要先组成数组，然后作为第二个参数传入
sayHi.apply(runEnv, [‘Hello!’]);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**在使用过程中如何选择**
1.1 如果给定参数列表是数组形式，选用apply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var items = [1, 2, 3, 4];&lt;/p&gt;

&lt;p&gt;// Math对象中的max方法，可以接受多个参数
// 如果需要梳理的元素是一个数组，那么我们可以使用apply使用方法
// 不用将数组中的元素一个个提取出来，在进行处理
var max = Math.max.apply(null, items);&lt;/p&gt;

&lt;p&gt;console.log(max);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.2 从性能方面考虑

![ECMA-262文档中call方法定义](http://upload-images.jianshu.io/upload_images/5796375-62cd08d9be00d3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![ECMA-262文档中apply方法定义](http://upload-images.jianshu.io/upload_images/5796375-2e6321f1913b6334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从这两个文档中我们可以发现，调用call方法，如果传入参数，直接从第二个参数从左向右将参数添加到argList中即可，而apply方法要调用一个CreateListFromArrayLike方法，将传入的数组元素处理为合法的argList，因此在可能存在性能上的差异。

jsPerf中对其运行性能进行对比发现[对比结果](https://github.com/coderwin/__/issues/6)。在参数较少(1-3)个时采用call的方式调用（lodash就是采用这种方式重写的）。

2. bind方法和其他两种方法的不同之处
bind方法，是ES5才提出的，其主要的不同就在于，call和apply方法，**是在指定的作用域上直接运行函数**，而bind方法是**创建一个新的函数**供后期直接使用，其传入的参数，也会直接绑定到这个新函数上。

2.1 bind函数的运行作用域
即使在全局作用域中运行，或者用call或者apply绑定其他作用域，都不会改变其运行作用域。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}&lt;/p&gt;

&lt;p&gt;// 创建一个空对象
var emptyObj = {};
// 将函数的this指向emptyObj，获取一个新的函数
var bindPerson = Person.bind(emptyObj);
// 在全局中运行该函数
bindPerson(‘yyp’, 18);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![运行后emptyObj对象内容](http://upload-images.jianshu.io/upload_images/5796375-27877ff3252be3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

运行绑定后获取的新函数时，此时我们已经将this绑定到制定的空对象上，运行bindPerson函数，相当于运行Person.call(emptyObj, 'yyp', 18);因此会在emptyObj上添加两个属性name和age。

2.2 bind时绑定提前绑定参数
如果在调用bind函数时，提供传入参数时，此时这些参数，将会直接绑定到新函数上，后续执行新函数传入的参数将会追加到这些参数后面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function Person(name, age) {
	this.name = name;
	this.age = age;
}&lt;/p&gt;

&lt;p&gt;var emptyObj = {};
// 此时提供一个参数
var bindPerson = Person.bind(emptyObj, ‘yyp’);
// 调用时提供一个参数，此时效果和前一个保持一致
bindPerson(18);&lt;/p&gt;

&lt;p&gt;// 提供两个参数时，根据实际参数情况，会丢掉后面的参数
// bindPerson(‘yyp’, 18);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.3 使用new调用函数时，出现的问题
使用new函数进行调用时，this不会指向bind时设定的对象，而是和直接使用new调用原始函数行为保持一致，但是之前提前绑定的参数，还是会生效。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}&lt;/p&gt;

&lt;p&gt;var emptyObj = {};
var bindPerson = Person.bind(emptyObj);&lt;/p&gt;

&lt;p&gt;var person = new bindPerson(‘yyp’, 18);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
![使用new调用函数时运行结果](http://upload-images.jianshu.io/upload_images/5796375-52a6407612cd98e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面运行结果可以发现，使用new调用时，绑定的作用于失效，this原先的this，因此emptyObj还是为空。

##### 4. bind方法的实现原理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Function.prototype.bind = function(oThis) {
	// 判断调用这个方法的对象是不是一个函数
	if (typeof this !== ‘function’) {
		// closest thing possible to the ECMAScript 5
		// internal IsCallable function
		throw new TypeError(‘Function.prototype.bind - what is trying to be bound is not callable’);
	}
	// 处理传入的参数部分
	// aArgs：保存绑定时传入的参数
	// fToBind：指向需要绑定的函数
	// fNOP： 空函数
	// fBound：将要返回的函数引用
	var aArgs = Array.prototype.slice.call(arguments, 1),
		fToBind = this,
		fNOP = function() {},
		fBound = function() {
			// 绑定函数执行时运行的处理逻辑
			// 如果当前任何环境中运行，执行函数中的this为之前制定的作用域，即作用域不会做二次绑定
			// 如果使用new进行调用时，执行函数中的this不改变
			return fToBind.apply(this instanceof fNOP ?
				this :
				oThis,
				// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
				aArgs.concat(Array.prototype.slice.call(arguments)));
		};&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 维护原型关系
if (this.prototype) {
	// Function.prototype doesn't have a prototype property
	fNOP.prototype = this.prototype;
}

// 返回的函数fBound继承fNOP，是fNOP的一个实例，
// 作用：1. 维持原型链
// 2. 用new进行该函数调用时，此时的this是fNOP的一个实例
fBound.prototype = new fNOP();

return fBound; }; ````     由上面代码可以了解到，调用bind函数进行绑定后，会返回一个新的函数，并且将调用时传入的参数保存起来。当调用这个绑定函数时，先判断this的指向，如果是使用new调用，this将会是bind函数的实例(绑定函数又是内部fNOP的实例)，直接使用当前this；如果是其他情况，则直接在之前绑定的运行作用域上执行。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">目录 函数中this是什么 如何改变this的指向（call, apply, bind） 上述方法的不同点 bind方法的实现原理</summary></entry><entry><title type="html">MAC终端中如何在命令行中启动Sublime编辑器</title><link href="http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%90%AF%E5%8A%A8Sublime%E7%BC%96%E8%BE%91%E5%99%A8.html" rel="alternate" type="text/html" title="MAC终端中如何在命令行中启动Sublime编辑器" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%90%AF%E5%8A%A8Sublime%E7%BC%96%E8%BE%91%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%90%AF%E5%8A%A8Sublime%E7%BC%96%E8%BE%91%E5%99%A8.html">&lt;h3 id=&quot;目标&quot;&gt;目标&lt;/h3&gt;
&lt;p&gt;在终端输入__&amp;gt; sublime__，可以直接打开sublime应用程序；在终端输入__&amp;gt; sublime 文件或者目录__，打开sublime应用并打开对应的文件或目录。&lt;/p&gt;

&lt;h3 id=&quot;实现方法&quot;&gt;实现方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建快捷方式
使用软连接（可以理解为快捷方式）将Sublime提供的命令行工具直接连接到/usr/local/bin/这个路径下。将/usr/local/bin/subl连接到Mac下的sublime应用提供的命令行工具subl。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-2fe59d0e69af81b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;执行结果&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改命令名
完成上面步骤，我们便可以直接通过subl命令打开sublime应用程序了，如果你想通过sublime这个命令打开的话，需要通过别名进行设置（个人尝试直接用ln连接创建sublime连接时会提示报错）
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-73feaf02416ab239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;报错&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;用vim 打开~/.bashrc进行编辑，在任意位置（最好是顶部）添加下面一行即可，然后执行source ~/.bashrc，使得修改生效即可。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alias sublime='subl'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-4adb7daf6e62c466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;.bashrc中的修改&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;执行命令流程图&quot;&gt;执行命令流程图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-35f325fda24fc778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;流程图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用软连接，而不是使用硬链接，软连接相当于一个快捷方式，而硬链接相当于创建了一个指向该可直接文件的指针，当卸载sublime后，由于还有指针指向该文件，因此依旧可以访问这个可执行文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能将自己创建的命令放置在/usr/local/bin/目录下，因为/bin和/sbin存放的是操作系统的可执行命令，/usr/bin和/usr/sbin存放的是应用软件的命令。而/usr/local/bin/可以存放用户自定义的命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确保你链接路径在PATH变量中，否则无法通过PATH查找到可执行命令。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.&lt;/p&gt;</content><author><name></name></author><summary type="html">目标 在终端输入__&amp;gt; sublime__，可以直接打开sublime应用程序；在终端输入__&amp;gt; sublime 文件或者目录__，打开sublime应用并打开对应的文件或目录。</summary></entry><entry><title type="html">MAC终端实用命令工具</title><link href="http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7.html" rel="alternate" type="text/html" title="MAC终端实用命令工具" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7</id><content type="html" xml:base="http://localhost:4000/tool/2018/10/05/MAC%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7.html">&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;brew命令行工具&lt;/li&gt;
  &lt;li&gt;压缩文件&lt;/li&gt;
  &lt;li&gt;目录树tree&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;持续更新中…&lt;/p&gt;

&lt;h4 id=&quot;1-brew命令行工具&quot;&gt;1. brew命令行工具&lt;/h4&gt;
&lt;p&gt;在开始之前，需要了解一件事情：在Mac命令行安装工具，一般都可以通过Homebrew这个工具进行安装。Mac系统中并没有内置这个命令行工具，因此在使用它安装其他工具前需要通过&lt;strong&gt;brew&lt;/strong&gt;或者&lt;strong&gt;brew -v&lt;/strong&gt;先检测系统中时候安装了改命令行工具。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-f336fed2d33aa767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;brew命令&quot; /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-b762e83c4322f0f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;查看brew命令&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果提示&lt;strong&gt;command not found&lt;/strong&gt;，说明你还没有安装brew命令行工具，此时你只需&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew官网&lt;/a&gt;获取安装命令，直接粘贴到命令行中运行即可，命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;安装好brew命令后，便可以在命令行中直接使用该命令安装，更新，卸载工具了。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install 安装 
brew upgrade 更新
brew uninstall 卸载
brew list 工具列表
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;2-压缩文件&quot;&gt;2. 压缩文件&lt;/h4&gt;
&lt;p&gt;在Mac命令行中，默认提供gzip，bzip2，zip压缩命令。&lt;/p&gt;

&lt;p&gt;使用gzip压缩后的文件后缀为.gz，使用bzip2压缩后的文件后缀为.bz2，使用zip压缩后的文件为.zip。&lt;/p&gt;

&lt;p&gt;这三种命令的使用方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip:
压缩命令：gzip 1.js  // 压缩目录的时候加上-r，目录中的每个文件都进行压缩
解压命令：gzip -d 1.js.gz 

bzip2:
压缩命令：bzip2 1.js
解压命令：bzip2 -d 1.js.bz2

zip:
压缩命令：zip 1.js.zip 1.js 
解压命令：unzip 1.js.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-c7c1980da1529fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gzip压缩解压&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-6ce33aca1485b0f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;bzip2压缩解压&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-23546614441d4cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;zip压缩解压&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上面可知：gzip，bzip2基本一致，zip用法特殊。&lt;/p&gt;

&lt;p&gt;gzip，bzip2可以直接结合打包命令tar，对文件进行打包压缩以及解压解包，命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip打包压缩和解压命令：
tar -zcvf all.tar.gz *.js
tar -zxvf all.tar.gz *.js

bzip2打包压缩和解压命令：
tar -jcvf all.tar.bz2 *.js
tar -jxvf all.tar.bz2 *.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-1d69284dace3eb4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gzip打包压缩和解压过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;*** 重点 **&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**
上面是针对Mac自带压缩工具，有一些windows用户的压缩文件为.rar，默认情况下，mac是无法解压的，我们可以借助一些解压软件进行解压，同样我们也可以&lt;/strong&gt;使用命令行进行解压unrar**，而且安装方法非常简单。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install unrar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;安装完成后你就可以使用unrar命令解压你的rar文件了。&lt;/p&gt;

&lt;h4 id=&quot;3-目录树tree&quot;&gt;3. 目录树tree&lt;/h4&gt;
&lt;p&gt;通常情况下，我们通过ls命令可以看到当前文件夹中的内容，但是且不能看到文件夹中的文件夹的内容，且展示方式并不人性化，使用tree命令，可以直观的展示当前文件夹，或者指定文件夹目录结构。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ruby
brew install tree
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;安装tree工具依赖ruby，确保你已经安装了ruby&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-dd6cf7e458fb6c6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;tree命令显示目录结构&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">目录 brew命令行工具 压缩文件 目录树tree</summary></entry><entry><title type="html">Nodejs中的事件循环</title><link href="http://localhost:4000/node/2018/10/05/Nodejs%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html" rel="alternate" type="text/html" title="Nodejs中的事件循环" /><published>2018-10-05T20:20:29+08:00</published><updated>2018-10-05T20:20:29+08:00</updated><id>http://localhost:4000/node/2018/10/05/Nodejs%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF</id><content type="html" xml:base="http://localhost:4000/node/2018/10/05/Nodejs%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html">&lt;p&gt;看到很多文件介绍关于Node.js中的事件循环，但是总是有些地方不是很理解，最近无意中看到了Node官方文档中对&lt;strong&gt;事件循环（Event Loop）&lt;/strong&gt;的介绍后，感觉有一种豁然开朗的感觉，但是其文档是英文版，在此，根据个人理解，进行翻译。
原文地址：&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;事件循环: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;翻译名词解释&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Event Loop&lt;/strong&gt;: 事件循环&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;poll phase&lt;/strong&gt;: 轮训阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;翻译内容&quot;&gt;翻译内容&lt;/h2&gt;
&lt;h3 id=&quot;事件循环&quot;&gt;事件循环&lt;/h3&gt;
&lt;p&gt;事件循环通过尽可能的将相应操作分担给系统内核，从而让单线程的Javascript语言提供了&lt;strong&gt;非阻塞I/O&lt;/strong&gt;操作。
因为目前主流的内核都是多线程的，它们可以同时在后台执行多个操作。当其中的某个操作完成时，系统就会通知Node.js与其相关的回调函数添加到&lt;strong&gt;轮训队列(poll queue)&lt;/strong&gt;中，最后被执行。这将在后续中详细讨论。&lt;/p&gt;

&lt;h3 id=&quot;事件循环介绍&quot;&gt;事件循环介绍&lt;/h3&gt;
&lt;p&gt;当Node.js运行，将会初始化一个事件循环，处理那些通过异步api调用，定时器，或者调用process.nextTick()提供的script（或者输入到REPL中的script）。
下图展示了&lt;strong&gt;事件循环的操作顺序&lt;/strong&gt;的概要。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5796375-94776ac39f97ca4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Event Loop&quot; /&gt;
&lt;strong&gt;注意：&lt;/strong&gt;图中每一个box代表事件循环的一个阶段。&lt;/p&gt;

&lt;p&gt;每个阶段都会维持一个先进先出的可执行回调函数队列。当然每个阶段都有自己特殊的行为方式，即当事件循环进入一个给定的阶段，它执行这个阶段的任何操作，然后执行这个阶段队列中的回调函数直到队列为空，或者回调函数调用次数达到上限。当满足这两个条件后，事件循环会进入下一个阶段。&lt;/p&gt;

&lt;p&gt;由于任何操作都有可能规划更多的操作，这操作都会添加到对应阶段的队列中进行排队（并非原文翻译，个人解读）。因此，需要占用大量时间运行的回调会让poll阶段运行更长的事件，设置超过定时器规定的时限。下面内容会详细说明这种情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在Windows和Unix/Linux实现中有轻微的差异，但是并不重要。这里讲解最重要的部分。&lt;/p&gt;

&lt;h3 id=&quot;各个阶段介绍&quot;&gt;各个阶段介绍&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;timers:&lt;/strong&gt; 这个阶段执行通过setTimeout()和setInterval()安排的回调函数。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;I/O callback:&lt;/strong&gt; 这个阶段执行关于close callback（如关闭socket调用的回调）， 定时器安排的回调，调用setImmediate()设置的回调中产生的异常后调用的回调函数。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;idle:&lt;/strong&gt; 内部使用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;poll:&lt;/strong&gt; I/O事件回调；在这个阶段node会根据实际情况进行堵塞。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;check:&lt;/strong&gt; 由setImmediate()设置的回调函数。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;close callbacks:&lt;/strong&gt; 如socket.on(‘close’, …)设置的回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在事件循环执行过程中，Node.js检查是否有有需要等待的异步I/O，定时器，如果没有，结束事件循环。&lt;/p&gt;

&lt;h3 id=&quot;各个阶段详解&quot;&gt;各个阶段详解&lt;/h3&gt;
&lt;h4 id=&quot;timers&quot;&gt;timers&lt;/h4&gt;
&lt;p&gt;定时器需要指定一个时限，然而提供的回调函数的等待事件可能超过用户期望其运行的具体时间。定时器回调函数会在到达时限后尽可能早的执行，而且系统调度或者正在运行的其他回调函数会延迟他的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;poll阶段控制timers的执行。&lt;/p&gt;

&lt;p&gt;如：假如设置一个100ms后执行的定时器，然后在第95ms你的异步文件读取完成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() =&amp;gt; {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);


// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() =&amp;gt; {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback &amp;lt; 10) {
    // do nothing
  }
});
const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() =&amp;gt; {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);


// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() =&amp;gt; {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback &amp;lt; 10) {
    // do nothing
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当事件循环进入poll阶段（轮训），此时轮训阶段的队列为空（因为fs.readFile()还没有完成），所以它等待剩余的时间，直到最近的定时器时限到达。当它等待了95ms后，fs.readFile()完成了文件读取，而它的加入到poll队列中回调函数需要10ms完成执行。当回调函数执行完成后，poll队列中已经没有其他回调函数，所以时间循环检查时间最近的那个定时器的时限是否已经到达，然后回到timers阶段来执行定时器的回调函数。在这个例子中，你将看到从定时器设置到回调的执行总共延迟将会是105ms。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了防止poll阶段耗尽事件循环，libuv(实现Node.js事件循环以及所有该平台异步行为的C类库)设置了精确的最大值（具体值取决于系统）用于停止轮训更多的事件。&lt;/p&gt;

&lt;h4 id=&quot;io回调函数&quot;&gt;I/O回调函数&lt;/h4&gt;
&lt;p&gt;这个阶段执行一些系统操作如TCP错误调用的回调函数。例如：如果TCP socket尝试连接时，接收到ECONNREFUSED，一些*nix系统等待报告这个错误。这将在I/O callback阶段排队执行。&lt;/p&gt;

&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;
&lt;p&gt;poll阶段有两个主要的功能：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为到达时限的定时器，执行脚本（不准确，其实是在poll队列中轮空时，检查定时器是否到达时限，如果到达了，则回到timers阶段执行定时器回调函数）&lt;/li&gt;
  &lt;li&gt;执行poll队列中的事件回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当事件循环进入poll阶段，并且此时没有设置定时器，将会发生下面两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果poll队列不是空的，事件循环将同步迭代执行队列中的回调函数，直到poll队列为空，或者达到执行上限。&lt;/li&gt;
  &lt;li&gt;如果poll队列为空的，将会发生下面两种情况：
1）如果脚本通过setImmediate()设置，事件循环会结束poll阶段，然后进入check阶段来执行这些脚本。
2）如果此时没有通过setImmediate()设置的脚本，事件循环将停留在poll阶段，等待回调函数添加到队列中，然后立即执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦poll队列为空，事件循环将检查已经达到时限的定时器。如果一个或多个定时器已经准备就绪，时间循环将回到timers阶段，执行这些定时器回调函数。&lt;/p&gt;

&lt;h4 id=&quot;check&quot;&gt;check&lt;/h4&gt;
&lt;p&gt;这个阶段，在poll阶段完成后，允许立即执行回调函数。如果poll阶段闲置，且存在setImmediate()设置的队列，事件循环将会进入check阶段，而不是继续等待。&lt;/p&gt;

&lt;p&gt;setImmediate()实际上是一个特殊的定时器，在事件循环中占据独立的阶段。它使用libuv API设置poll阶段完成后的执行回调函数。&lt;/p&gt;

&lt;p&gt;总体上，伴随着代码执行完，事件循环将会进入poll阶段来等待即将到达的网络连接，请求等。然而，如果此时有使用setImediate()设置的回调函数，并且poll阶段闲置，事件循环结束poll阶段，进入check阶段而不是等待poll事件。&lt;/p&gt;

&lt;h4 id=&quot;close-callbacks&quot;&gt;close callbacks&lt;/h4&gt;
&lt;p&gt;如果一个sokect忽然关闭（如：socket.destroy()），’close’事件将会在这个阶段触发。process.nextTick()也会触发（个人理解：这个不需要强行理解，下面有process.nextTick()具体介绍）。&lt;/p&gt;

&lt;h3 id=&quot;setimmediate-vs-settimeout&quot;&gt;setImmediate() vs setTimeout()&lt;/h3&gt;
&lt;p&gt;setImmediate()和setTimeout()两者相似，但是调用时机不同。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;setImmediate()设计用来当当前poll阶段完成是执行脚本。&lt;/li&gt;
  &lt;li&gt;setTimeout()经过给定时间后执行脚本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个定时器的执行顺序非常的依赖调用上下文。如果两个都是在主模块中调用，定时器将会受到执行过程的约束（可能会收到机器上运行的其他应用影响）。&lt;/p&gt;

&lt;p&gt;如，如果我们执行下面的脚本，这两个定时器的执行顺序是不确定的，因为它受到执行过程的约束。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// timeout_vs_immediate.js
setTimeout(() =&amp;gt; {
  console.log('timeout');
}, 0);

setImmediate(() =&amp;gt; {
  console.log('immediate');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然而，如果你将这两个定时器设置在I/O回调中，immediate回调函数总是会现在执行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// timeout_vs_immediate.js
const fs = require('fs');

fs.readFile(__filename, () =&amp;gt; {
  setTimeout(() =&amp;gt; {
    console.log('timeout');
  }, 0);
  setImmediate(() =&amp;gt; {
    console.log('immediate');
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用setImmediate()函数主要优势是设置在I/O回调中setImmediate()不管当前有多少定时器，总是比其他定时器先执行。&lt;/p&gt;

&lt;h3 id=&quot;processnexttick&quot;&gt;process.nextTick()&lt;/h3&gt;
&lt;h4 id=&quot;理解processnexttick&quot;&gt;理解process.nextTick()&lt;/h4&gt;
&lt;p&gt;你可能意识到process.nextTick()并没有出现在事件循环的图中，即便它是异步API的一部分。这是因为process.nextTick()严格意义上来说，并不属于事件循环。取而代之的是，nextTickQueue将会忽略当前事件循环的阶段，在当前操作完成之后执行。&lt;/p&gt;

&lt;p&gt;回顾事件循环结构图，在一个特定阶段的任何时间调用process.nextTick()，所有传入process.nextTick()的回调函数将会在事件循环继续之前执行。这可能会造成一些不良情况，因为这允许你通过迭代调用process.nextTick()耗尽I/O，从而使得事件循环不能进入poll阶段。&lt;/p&gt;

&lt;h4 id=&quot;为什么允许上述情况&quot;&gt;为什么允许上述情况&lt;/h4&gt;
&lt;p&gt;为什么会允许上述情况出现在Node.js中？Node.js的设计思想是尽可能的异步，即使并不需要异步。如下代码片段：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function apiCall(arg, callback) {
  if (typeof arg !== 'string')
    return process.nextTick(callback,
                            new TypeError('argument should be string'));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个片段进行了参数类型的检测，如果类型不一致，就传递一个err到回调函数中。其中，需要传入回调函数中的参数，直接写在回调函数的后面即可。&lt;/p&gt;

&lt;p&gt;我们这里做的事情是，传递一个error给回调函数，但是这个回调会在用户的剩余代码执行完之后才会执行。通过使用process.nextTick()，我们保证apiCall()总是在剩余代码执行之后事件循环继续之前执行回调函数。为了实现这些，允许JS调用栈展开，然后立即执行process.nextTick()提供的回调函数。这个回调中允许迭代调用process.nextTick()而不会触发RangeError: Maximum call stack size exceeded from v8。&lt;/p&gt;

&lt;p&gt;这个思想会导致一些潜在的问题。如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let bar;

// this has an asynchronous signature, but calls callback synchronously
function someAsyncApiCall(callback) { callback(); }

// the callback is called before `someAsyncApiCall` completes.
someAsyncApiCall(() =&amp;gt; {
  // since someAsyncApiCall has completed, bar hasn't been assigned any value
  console.log('bar', bar); // undefined
});

bar = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;开发者定义了someAsyncApiCall()具有异步的特征，但是它其实是一个通过操作。当它被调用，回调函数提供someAsyncApiCall()会在当前事件循环阶段被调用，因为someAsyncApiCall()其实没有做任何异步处理。结果，回调函数尝试引用bar，即使此时bar还没有进行赋值（此时代码还没有运行到bar = 1;这条语句）。&lt;/p&gt;

&lt;p&gt;通过将回到函数设置在process.nextTick()中，脚本将会有机会运行完成，允许变量，函数初始化完成后，在调用回调函数。使用process.nextTick()阻止事件循环继续进行还有一个优势。在事件循环继续执行前，将处理当前事件循环中出现的错误。下面是上一个实例的正确做法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let bar;

function someAsyncApiCall(callback) {
  process.nextTick(callback);
}

someAsyncApiCall(() =&amp;gt; {
  console.log('bar', bar); // 1
});

bar = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面是一个真实的例子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const server = net.createServer(() =&amp;gt; {}).listen(8080);

server.on('listening', () =&amp;gt; {});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当listen()函数中，只传递端口号时，端口后会立马进行设置。所以，’listening’回调函数将会立马被调用。问题是.on(‘listening)回调函数将不会那个时候设置。
为了绕过这个，’listening’事件在nextTick()中排队，从而运行脚本执行完成后在触发。这允许开发者设置任意设置事件回调函数。&lt;/p&gt;

&lt;h3 id=&quot;processnexttick-vs-setimmediate&quot;&gt;process.nextTick() vs setImmediate()&lt;/h3&gt;
&lt;p&gt;就用户而言，这两个函数相似，但是它们的名字很令人迷惑。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;process.nextTick()在同一个阶段执行&lt;/li&gt;
  &lt;li&gt;setImmediate()在事件循环的下一个阶段或者’tick’中执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本质上，它们的名字需要交换一下。process.nextTick()比setImmediate()更快被执行，但是这是过去的产物，很难修改。修改这个问题将会导致一大部分的npm包出现损坏。每天有更多的模块被添加，这意味着更多潜在的损坏会出现。因此即使它们的名字令人迷惑，名字不会修改。&lt;/p&gt;

&lt;p&gt;我们提倡开发者使用setImmediate()，因为setImmediate()具有更好的兼容性，如在浏览器中。&lt;/p&gt;

&lt;h3 id=&quot;为什么使用processnexttick&quot;&gt;为什么使用process.nextTick()&lt;/h3&gt;
&lt;p&gt;这里有两个主要的原因:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在事件循环继续之前允许用户处理错误，清除任何之后不需要的资源，或者可能再次请求等。&lt;/li&gt;
  &lt;li&gt;需要回调函数在调用堆栈上但是在事件循环继续之前调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面例子符合用户的期望，如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const server = net.createServer();
server.on('connection', (conn) =&amp;gt; { });

server.listen(8080);
server.on('listening', () =&amp;gt; { });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;listen()在第一轮事件循环执行，但是listening事件的回调函数是通过setImmediate()设置的（与前面描述不一致，但是大致可以理解为，触发listening事件的语句放置在一个异步api，当其触发listening事件时，此时server.on(‘listening’, () =&amp;gt; { });已经执行完成）。要使事件循环继续进行，它必须到达轮询阶段，这意味着可能没有收到连接的机会，允许连接事件在侦听事件之前被触发。（listening事件先被触发，connection事件之后被触发）。&lt;/p&gt;

&lt;p&gt;另一个例子，运行一个函数构造函数，继承EventEmitter并且在构造函数内部触发一个事件。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);
  this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () =&amp;gt; {
  console.log('an event occurred!');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;你不能在构造函数中立马触发事件，因此此时，脚本中还没有设置改时间的回调函数。所以，在构造函数中，你可以使用process.nextTick()来设置一个触发事件的回调函数，这将会达到预定的效果。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);

  // use nextTick to emit the event once a handler is assigned
  process.nextTick(() =&amp;gt; {
    this.emit('event');
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () =&amp;gt; {
  console.log('an event occurred!');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">看到很多文件介绍关于Node.js中的事件循环，但是总是有些地方不是很理解，最近无意中看到了Node官方文档中对事件循环（Event Loop）的介绍后，感觉有一种豁然开朗的感觉，但是其文档是英文版，在此，根据个人理解，进行翻译。 原文地址：事件循环: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</summary></entry></feed>